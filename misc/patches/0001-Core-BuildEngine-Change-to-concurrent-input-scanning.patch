From 73345865b0a451bb62c9791c8c9605c60b10e88e Mon Sep 17 00:00:00 2001
From: Daniel Dunbar <daniel_dunbar@apple.com>
Date: Wed, 12 Nov 2014 13:52:14 -0800
Subject: [PATCH] [Core/BuildEngine] Change to concurrent input scanning.

 - This approach uses a separate single input queue to execute all of the
   deferred requests, which simplifies the structures that need to be tracked.

 - This approach is fairly clean, but causes a dramatic performance regression
   on "ack --recompute 10 3 11" (around 80%), which needs to be understood.

 - The performance impact on dependency scanning is roughly::
   o CorePerf: +70.3%
   o LinearChain: -5.9%
   o NaryTree: +9.5%
   o 2DMatrix: +100%

---
 lib/Core/BuildEngine.cpp | 123 +++++++++++++++++++++++++++++++++--------------
 1 file changed, 87 insertions(+), 36 deletions(-)

diff --git a/lib/Core/BuildEngine.cpp b/lib/Core/BuildEngine.cpp
index 90cba50..881e57d 100644
--- a/lib/Core/BuildEngine.cpp
+++ b/lib/Core/BuildEngine.cpp
@@ -53,18 +53,16 @@ class BuildEngineImpl {
   std::vector<TaskInputRequest> InputRequests;
 
   /// The queue of rules being scanned.
-  struct RuleScanRequest {
-    /// The rule making the request.
+  std::vector<RuleInfo*> RuleInfosToScan;
+
+  /// The queue of deferred input scans to process.
+  struct RuleInputScanRequest {
+     /// The rule making the request.
     RuleInfo* RuleInfo;
-    /// The input index being considered.
-    unsigned InputIndex;
-    /// The input being considered, if already looked up.
-    ///
-    /// This is used when a scan request is deferred waiting on its input to be
-    /// scanned, to avoid a redundant hash lookup.
+    /// The input being considered.
     struct RuleInfo* InputRuleInfo;
   };
-  std::vector<RuleScanRequest> RuleInfosToScan;
+  std::vector<RuleInputScanRequest> RuleInfoInputsToScan;
 
   struct RuleScanRecord {
     /// The vector of paused input requests, waiting for the dependency scan on
@@ -72,7 +70,10 @@ class BuildEngineImpl {
     std::vector<TaskInputRequest> PausedInputRequests;
     /// The vector of deferred scan requests, for rules which are waiting on
     /// this one to be scanned.
-    std::vector<RuleScanRequest> DeferredScanRequests;
+    std::vector<RuleInfo*> DeferredScanRequests;
+    /// The number of deferred scan requests for the rule scanned with this
+    /// record.
+    unsigned ScanWaitCount = 0;
   };
 
   /// The map of rule information.
@@ -331,7 +332,7 @@ private:
       Trace->ruleScheduledForScanning(&RuleInfo.Rule);
     RuleInfo.State = RuleInfo::StateKind::IsScanning;
     RuleInfo.setPendingScanRecord(newRuleScanRecord());
-    RuleInfosToScan.push_back({ &RuleInfo, /*InputIndex=*/0, nullptr });
+    RuleInfosToScan.push_back(&RuleInfo);
 
     return false;
   }
@@ -403,25 +404,18 @@ private:
   ///
   /// This will process all of the inputs required by the requesting rule, in
   /// order, unless the scan needs to be deferred waiting for an input.
-  void processRuleScanRequest(RuleScanRequest Request) {
-    auto& RuleInfo = *Request.RuleInfo;
-
+  void processRuleScanRequest(RuleInfo& RuleInfo) {
     assert(RuleInfo.isScanning());
 
     // Process each of the remaining inputs.
-    do {
-      // Look up the input rule info, if not yet cached.
-      if (!Request.InputRuleInfo) {
-        auto it = RuleInfos.find(
-          RuleInfo.Result.Dependencies[Request.InputIndex]);
-        if (it == RuleInfos.end()) {
-          // FIXME: What do we do here? Probably just rebuild.
-          assert(0 && "prior input dependency no longer exists");
-          abort();
-        }
-        Request.InputRuleInfo = &it->second;
+    for (const auto& InputKey: RuleInfo.Result.Dependencies) {
+      auto it = RuleInfos.find(InputKey);
+      if (it == RuleInfos.end()) {
+        // FIXME: What do we do here? Probably just rebuild.
+        assert(0 && "prior input dependency no longer exists");
+        abort();
       }
-      auto& InputRuleInfo = *Request.InputRuleInfo;
+      auto& InputRuleInfo = it->second;
 
       // Scan the input.
       bool IsScanned = scanRule(InputRuleInfo);
@@ -433,8 +427,9 @@ private:
           Trace->ruleScanningDeferredOnInput(&RuleInfo.Rule,
                                              &InputRuleInfo.Rule);
         InputRuleInfo.getPendingScanRecord()
-          ->DeferredScanRequests.push_back(Request);
-        return;
+          ->DeferredScanRequests.push_back(&RuleInfo);
+        RuleInfo.getPendingScanRecord()->ScanWaitCount++;
+        continue;
       }
 
       if (Trace)
@@ -466,11 +461,11 @@ private:
         finishScanRequest(RuleInfo, RuleInfo::StateKind::NeedsToRun);
         return;
       }
+    }
 
-      // Otherwise, increment the scan index.
-      ++Request.InputIndex;
-      Request.InputRuleInfo = nullptr;
-    } while (Request.InputIndex != RuleInfo.Result.Dependencies.size());
+    // If we have deferred scan requests, wait to be reprocessed.
+    if (RuleInfo.getPendingScanRecord()->ScanWaitCount != 0)
+      return;
 
     // If we reached the end of the inputs, the rule does not need to run.
     if (Trace)
@@ -478,14 +473,60 @@ private:
     finishScanRequest(RuleInfo, RuleInfo::StateKind::DoesNotNeedToRun);
   }
 
+  void processRuleInputScanRequest(RuleInputScanRequest Request) {
+    auto& RuleInfo = *Request.RuleInfo;
+    auto& InputRuleInfo = *Request.InputRuleInfo;
+
+    // If the rule has already transitioned, ignore the request.
+    if (RuleInfo.State != RuleInfo::StateKind::IsScanning)
+      return;
+
+    // Decrement the scan wait count.
+    --RuleInfo.getPendingScanRecord()->ScanWaitCount;
+
+    // Demand the input.
+    bool IsAvailable = demandRule(InputRuleInfo);
+
+    // If the input wasn't already available, it needs to run.
+    if (!IsAvailable) {
+      // FIXME: This is just wrong, just because we haven't run the task yet
+      // doesn't necessarily mean that this rule needs to run, if running
+      // the task results in an output that hasn't changed (and so
+      // ComputedAt isn't updated). This case doesn't come up until we
+      // support BuiltAt != ComputedAt, though.
+      if (Trace)
+        Trace->ruleNeedsToRunBecauseInputUnavailable(
+          &RuleInfo.Rule, &InputRuleInfo.Rule);
+      finishScanRequest(RuleInfo, RuleInfo::StateKind::NeedsToRun);
+      return;
+    }
+
+    // If the input has been computed since the last time this rule was
+    // built, it needs to run.
+    if (RuleInfo.Result.BuiltAt < InputRuleInfo.Result.ComputedAt) {
+      if (Trace)
+        Trace->ruleNeedsToRunBecauseInputRebuilt(
+          &RuleInfo.Rule, &InputRuleInfo.Rule);
+      finishScanRequest(RuleInfo, RuleInfo::StateKind::NeedsToRun);
+      return;
+    }
+
+    // If this is the last pending scan request, the rule does not need to run.
+    if (RuleInfo.getPendingScanRecord()->ScanWaitCount == 0) {
+      if (Trace)
+        Trace->ruleDoesNotNeedToRun(&RuleInfo.Rule);
+      finishScanRequest(RuleInfo, RuleInfo::StateKind::DoesNotNeedToRun);
+    }
+  }
+
   void finishScanRequest(RuleInfo& InputRuleInfo,
                          RuleInfo::StateKind NewState) {
     assert(InputRuleInfo.isScanning());
     auto ScanRecord = InputRuleInfo.getPendingScanRecord();
 
     // Wake up all of the pending scan requests.
-    for (const auto& Request: ScanRecord->DeferredScanRequests) {
-      RuleInfosToScan.push_back(Request);
+    for (const auto& RuleInfo: ScanRecord->DeferredScanRequests) {
+      RuleInfoInputsToScan.push_back({ RuleInfo, &InputRuleInfo });
     }
 
     // Wake up all of the input requests on this rule.
@@ -513,10 +554,20 @@ private:
       while (!RuleInfosToScan.empty()) {
         DidWork = true;
 
-        auto Request = RuleInfosToScan.back();
+        auto& RuleInfo = *RuleInfosToScan.back();
         RuleInfosToScan.pop_back();
 
-        processRuleScanRequest(Request);
+        processRuleScanRequest(RuleInfo);
+      }
+
+      // Process all of the pending individual input scan requests.
+      while (!RuleInfoInputsToScan.empty()) {
+        DidWork = true;
+
+        auto Request = RuleInfoInputsToScan.back();
+        RuleInfoInputsToScan.pop_back();
+
+        processRuleInputScanRequest(Request);
       }
 
       // Process all of the pending input requests.
-- 
2.1.1 (Apple Git-51)

