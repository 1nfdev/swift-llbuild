# Check that we communicate properly with the Swift compiler.
#
# RUN: rm -rf %t.build
# RUN: mkdir -p %t.build
# RUN: sed -e "s#SOURCEDIR#%S#g" -e "s#TMPDIR#%t#g" < %s > %t.build/build.swift-build
# RUN: %{swift-build-tool} --no-db --chdir %t.build > %t.out
# RUN: %{swift-build-tool} --no-db -v --chdir %t.build > %t-verbose.out
# RUN: %{FileCheck} --input-file=%t.out %s
# RUN: %{FileCheck} --check-prefix=CHECK-VERBOSE --input-file=%t-verbose.out %s
#
# CHECK: Compiling Swift Module 'Foo'
# CHECK-VERBOSE: swiftc -module-name Foo -incremental -emit-dependencies -emit-module -emit-module-path Foo.swiftmodule -output-file-map temps/output-file-map.json -parse-as-library -c s1.swift s2.swift -Iimport-A -Iimport-B -Onone

# Sanity check the output file map.
#
# RUN: %{FileCheck} --check-prefix=CHECK-OUTPUT-FILE-MAP --input-file=%t.build/temps/output-file-map.json %s
# CHECK-OUTPUT-FILE-MAP: "s1.swift": {
# CHECK-OUTPUT-FILE-MAP-NEXT: "dependencies": "temps/s1.d"

client:
  name: swift-build

targets:
  "": ["<output>"]

commands:
  C1:
    tool: swift-compiler
    outputs: ["<output>"]
    executable: SOURCEDIR/Inputs/pseudo-swiftc
    module-name: Foo
    module-output-path: Foo.swiftmodule
    sources: ["s1.swift", "s2.swift"]
    import-paths: ["import-A", "import-B"]
    objects: ["s1.o", "s2.o"]
    other-args: ["-Onone"]
    temps-path: temps
    is-library: true
