# Check that we allow all inputs to run in parallel, instead of pending the full scan.

# RUN: rm -rf %t.build
# RUN: mkdir -p %t.build
# RUN: cp %s %t.build/build.ninja
# RUN: cp %S/Inputs/wait-for-file %t.build
# RUN: %{llbuild} ninja build --chdir %t.build > %t1.out
# RUN: %{FileCheck} --check-prefix CHECK-INITIAL --input-file %t1.out %s
#
# CHECK-INITIAL: [1/{{.*}}] echo > in-{{[12]}}
# CHECK-INITIAL: [2/{{.*}}] echo > in-{{[12]}}
# CHECK-INITIAL: [5/{{.*}}] cat out-1 out-2 > output

# Perform the checking build, using the wait-for-file trick to check that the
# commands run in parallel.
#
# RUN: echo mod >> %t.build/in-1
# RUN: echo mod >> %t.build/in-2
# RUN: rm -f %t.build/in-1.semaphore
# RUN: rm -f %t.build/in-2.semaphore
# RUN: %{llbuild} ninja build --strict --chdir %t.build > %t2.out
# RUN: %{FileCheck} --check-prefix CHECK-PARALLEL-1 --input-file %t2.out %s
# RUN: %{FileCheck} --check-prefix CHECK-PARALLEL-2 --input-file %t2.out %s
#
# CHECK-PARALLEL-1: [{{.*}}] touch in-1.semaphore
# CHECK-PARALLEL-1: note: {{.*}}: waiting for file 'in-2.semaphore'
# CHECK-PARALLEL-1-NEXT: note: file 'in-2.semaphore' exists, exiting
# CHECK-PARALLEL-2: [{{.*}}] touch in-2.semaphore
# CHECK-PARALLEL-2: note: {{.*}}: waiting for file 'in-1.semaphore'
# CHECK-PARALLEL-2-NEXT: note: file 'in-1.semaphore' exists, exiting
# CHECK-PARALLEL-2: [3/{{.*}}] cat out-1 out-2 > output

rule ECHO
     command = echo ${in} > ${out}
rule CP
     command = touch ${semaphore} && ./wait-for-file ${in}.semaphore && if ! diff -q ${in} ${out} &> /dev/null; then cp ${in} ${out}; fi
     restat = 1
rule CAT
     command = cat ${in} > ${out}

build in-1: ECHO
build in-2: ECHO
build out-1: CP in-1
  semaphore = in-2.semaphore
build out-2: CP in-2
  semaphore = in-1.semaphore
build output: CAT out-1 out-2
