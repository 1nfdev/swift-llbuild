# Check build engine tracing of scanning events.

# RUN: rm -rf %t.build
# RUN: mkdir -p %t.build
# RUN: cp %s %t.build/build.ninja
# RUN: touch %t.build/input-1
# RUN: touch %t.build/input-2
# RUN: %{llbuild} ninja build --no-parallel --chdir %t.build --trace %t.trace-out

# Check dependency scanning on rebuild.
#
# RUN: echo "mod" >> %t.build/input-2
# RUN: %{llbuild} ninja build --no-parallel --chdir %t.build --trace %t.trace-out
# RUN: %{FileCheck} < %t.trace-out %s
#
# We scan "output", which pauses, then "input-1" (which doesn't need to run),
# then "input-2" (which does need to run), and then return to "output", which
# needs to run because of "input-2".
#
# CHECK: { "new-rule", "[[RULE1:.*]]", "output" },
# CHECK: { "checking-rule-needs-to-run", "[[RULE1]]" },
# CHECK: { "paused-input-request-for-rule-scan", "[[RULE1]]" },
# CHECK: { "new-rule", "[[RULE2:.*]]", "input-1" },
# CHECK: { "checking-rule-needs-to-run", "[[RULE2]]" },
# CHECK: { "rule-does-not-need-to-run", "[[RULE2]]" },
# CHECK: { "rule-scanning-next-input", "[[RULE1]]", "[[RULE2]]" },
# CHECK: { "new-rule", "[[RULE3:.*]]", "input-2" },
# CHECK: { "checking-rule-needs-to-run", "[[RULE3]]" },
# CHECK: { "rule-needs-to-run", "[[RULE3]]", "invalid-value" },
# CHECK: { "rule-needs-to-run", "[[RULE1]]", "input-unavailable", "[[RULE3]]" },

rule CAT
     command = cat ${in} > $out

build output: CAT input-1 input-2

default output
